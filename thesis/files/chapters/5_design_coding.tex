\chapter{Progettazione e codifica}
\label{chap:progettazione-codifica}
La fase di progettazione e codifica è stata la più significativa per il progetto in quanto ha occupato la maggior parte del tempo a disposizione.
Attraverso un incontro con il tutor aziendale sono stati definiti i \gls{frameworkg} per la codifica e l'architettura del sistema.
\section{Tecnologie e strumenti}
\label{sec:tecnologie-strumenti}
Di seguito viene data una panoramica delle tecnologie e strumenti utilizzati.
\subsection{Linguaggi e framework}
\subsubsection{Python}
Linguaggio di programmazione ad alto livello, orientato agli oggetti e adatto a sviluppare applicazioni distribuite.
Viene utilizzato nello sviluppo web, nell'analisi dei dati, nel machine learning e nello sviluppo di automazioni.
Permette di installare e gestire le librerie attraverso pip, un gestore di pacchetti.
\subsubsection{FastAPI}
\textit{Framework} web per la codifica di \textit{API} basato su Python\footcite{site:python}.
Offre elevate prestazioni, validazione dell'input attraverso l'utilizzo della libreria Pydantic\footcite{site:pydantic} e 
documentazione automatica seguendo lo standard OpenAPI\footcite{site:openapi}.
\subsubsection{Pytest}
\textit{Framework} che permette la scrittura e l'esecuzione di \gls{unitTestg}, \gls{functionalTestg} e \gls{integrationTestg}.
\subsection{Librerie}
\subsubsection{Black}
Libreria che permette di formattare il codice Python, utilizzata per imporre un \gls{codestyleg} unico e ripetibile.
\subsubsection{isort}
Libreria che permette di formattare le importazioni delle librerie Python, utilizzata per imporre un \textit{codestyle} unico e ripetibile.
\subsubsection{SQLModel}
Libreria che permette di interagire con basi di dati relazionali attraverso il codice scritto in Python con 
la tecnica di programmazione \gls{orm}.
\subsubsection{PyJWT}
Libreria che permette di codificare e decodificare \gls{jwt}, utilizzati per autenticare utenti o servizi.
\subsubsection{Pydantic}
Libreria che aggiunge funzionalità legate alla validazione dei dati in Python, permette di definire con precisione la struttura dei dati
e gestire i casi in cui si riceva un input non conforme alle aspettative.

\subsubsection{Google OR-Tools}
\label{library:or-tools}
Libreria che contiene strumenti per risolvere problemi di \gls{combinatorialOptimizationg}.
Permette di modellare un problema attraverso diversi linguaggi di programmazione (C++, Python, C\# o Java) e utilizzare
diversi risolutori commerciali o \gls{openSourceg}.
\subsection{DevOps e server di deploy}
\subsubsection{Docker}
Piattaforma utilizzata per creare ambienti isolati e riproducibili dove eseguire le applicazioni. 
Consente di standardizzare lo sviluppo locale e il \gls{deployg}, riducendo differenze tra ambienti e semplificando l'esecuzione dei servizi.
\subsubsection{Uvicorn}
Server di tipo \gls{asgi} per applicazioni web Python asincrone. Utilizzato per eseguire l'\textit{API} in sviluppo e in produzione, supporta la concorrenza.
\subsection{Persistenza dei dati}
\subsubsection{MySQL}
Sistema di gestione di basi di dati relazionali usato per la persistenza. 
Supporta transazioni e indici, ed è integrato con l'applicazione tramite \textit{ORM} per la definizione dello schema e l'accesso ai dati.

\section{Progettazione della base di dati}
\subsection{Base di dati del modulo di pianificazione}
\label{planner-database}
Assieme al tutor aziendale è stata presa la decisione di non utilizzare la base di dati del modulo di pianificazione per la persistenza dei risultati generati,
questo perché la coda di stampa viene visualizzata direttamente all'interno del software gestionale e risulta pertanto più semplice e intuitivo 
modificare direttamente il \textit{database} di quest'ultimo.
La base di dati del modulo di pianificazione ha il solo compito di memorizzare i \gls{clientg} registrati e autorizzati a chiamare le
\textit{API} esposte, a tale scopo è stata creata una sola tabella denominata \texttt{clients} e così strutturata:
\begin{itemize}
    \item \texttt{id}: intero auto-incrementale utilizzato come chiave primaria, generato automaticamente dal \textit{database}.
    \item \texttt{client\_id}: stringa obbligatoria indicizzata e univoca che identifica il client registrato.
    \item \texttt{client\_secret}: stringa obbligatoria che contiene la password utilizzata dal client per l'autenticazione (vedi \ref{section:system-security}).
    \item \texttt{created\_at}: campo di tipo \texttt{DateTime} per tracciare la data di registrazione.
    \item \texttt{is\_active}: valore booleano che indica se il client è abilitato, è valorizzato a \textit{true} di default.
\end{itemize}
Ciò permette, in futuro, di aggiungere eventuali altri \textit{client} autorizzati a utilizzare il modulo.
\subsection{Base di dati del software gestionale}
La progettazione della base di dati è risultata fondamentale per permettere all'utente di visualizzare correttamente le code di stampa pianificate.
Il software gestionale esistente (e già sviluppato al momento della codifica del progetto) possiede una base di dati già strutturata e utilizzata sia dall'azienda ospitante che da
alcuni clienti dell'azienda stessa (in quanto il software è \gls{multitenantg}).
Per questo motivo l'ampliamento della base di dati esistente è stato eseguito cercando di mantenere al minimo il numero di modifiche.

Sono state aggiunte due tabelle per tracciare gli output della pianificazione e il legame con gli ordini:
\begin{itemize}
    \item La tabella \texttt{scheduling\_results} così formata:
    \begin{itemize}
    \item \texttt{id}: intero auto-incrementale usato come chiave primaria;
    \item \texttt{user\_id}: chiave esterna verso la tabella \texttt{users} contenente i dati degli utenti registrati;
    \item \texttt{data}: campo \texttt{json} obbligatorio che memorizza il payload completo della soluzione;
    \item \texttt{is\_accepted}: boolean obbligatorio valorizzato di default a \textit{false} per indicare l'approvazione dell'utente;
    \item \texttt{created\_at}: campo di tipo \texttt{DateTime} per tracciare la data di ricezione del risultato;
    \item \texttt{updated\_at}: campo di tipo \texttt{DateTime} per tracciare la data dell'ultima modifica del risultato.
    \end{itemize}
    \item La tabella \texttt{scheduling\_results\_orders} così formata:
    \begin{itemize}
        \item \texttt{id}: intero auto-incrementale usato come chiave primaria;
        \item \texttt{order\_id}: chiave esterna verso la tabella \texttt{orders} contenente gli ordini ricevuti;
        \item \texttt{scheduling\_result\_id}: chiave esterna verso \texttt{scheduling\_results}.
    \end{itemize}
\end{itemize}

\section{Design pattern adottati}
Qui vengono descritti i \gls{designPatterng} comportamentali e di \gls{inversioneControllog} adottati.
\subsection{Architettura del sistema}
Il \gls{architecturalDesignPatterng} scelto per la codifica del progetto è il \gls{layerPatterng}.
Tale scelta è stata presa per le seguenti motivazioni:
\begin{itemize}
    \item Permette una buona separazione delle responsabilità, ogni \gls{layerg} non conosce infatti l'implementazione degli altri;
    \item Permette una maggior semplicità di sviluppo, in quanto è un \textit{design pattern architetturale} conosciuto e di semplice comprensione;
    \item Permette una buona manutenibilità del codice, ogni \textit{layer} non viene influenzato dai cambiamenti apportati ad altri layer (a patto che i \textit{contratti} tra i layer rimangano invariati);
    \item Permette una buona testabilità, ogni \textit{layer} può essere isolato e testato separatamente;
    \item Il progetto non richiede un'elevata \gls{scalabilityg} del sistema.
\end{itemize}
I \textit{layer} implementati all'interno del sistema sono i seguenti:
\begin{itemize}
    \item \textit{API layer}: rappresenta la logica che riceve le richieste HTTP e orchestra le chiamate ai servizi disponibili;
    \item \textit{Business layer}: rappresenta la logica di business dell'applicazione, riceve i dati dall'\textit{API layer} ed effettua le operazioni necessarie;
    \item \textit{Persistence layer}: rappresenta la connessione tra il \textit{business layer} e il \textit{database}, si occupa di eseguire le \textit{query} e orchestrare l'utilizzo del \textit{Object-Relational Mapper};
    \item \textit{Database layer}: rappresenta il \textit{database} dell'applicativo, dove i dati sono salvati e prelevati. 
\end{itemize}
Ogni \textit{layer} interagisce solo con i \textit{layer} sottostanti, pertanto è stato adottato un approccio di tipo \textit{closed layer}.
\subsection{Inversione del controllo}
È stato fatto utilizzo del sistema di \gls{dependencyInjectiong} messo a disposizione dal \textit{framework} FastAPI.
In particolare il file jwt.py espone le rotte \texttt{/verifyToken} e \texttt{/token} e delega le operazioni di verifica e 
generazione dei \textit{JSON Web Token} alle funzioni fornite dalla classe \texttt{JWTDependencies}. 
Tramite l'oggetto \texttt{Depends} il router richiede le dipendenze \texttt{get\_verified\_payload} per verificare il \textit{token} e \texttt{get\_new\_token} per generarne uno nuovo, lasciando che FastAPI risolva e inietti gli oggetti necessari prima dell'esecuzione dell'endpoint. 
Questo approccio sposta all'esterno la creazione delle dipendenze, permettendo di sostituire facilmente l'implementazione durante i test o in fase di configurazione dell'applicazione.
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/jwt.py}
\caption{File jwt.py}
\label{listing:jwt-py}
\end{listing}
\newpage
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/jwt_dependencies.py}
\caption{Classe JWTDependencies}
\label{listing:jwt-dependencies-py}
\end{listing}
\subsection{Design pattern comportamentali}
È stato usato lo \textit{strategy pattern} per definire un'interfaccia per l'algoritmo di ordinamento.
Tale scelta permetterà in futuro, se necessario, di riscrivere completamente la logica di schedulazione mantenendo la compatibilità con la restante logica 
del modulo, a patto che venga implementata la stessa interfaccia.
La definizione viene fornita nel file \texttt{ordering\_alg.py}.
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/ordering_alg.py}
\caption{Interfaccia schedule\_jobs}
\label{listing:ordering-alg-py}
\end{listing}
La lista dei parametri accettati è la seguente:
\begin{itemize}
    \item \texttt{jobs}: \textit{array} di lavori da pianificare;
    \item \texttt{printers}: \textit{array} di stampanti disponibili;
    \item \texttt{base\_datetime}: data e ora di riferimento da cui far partire la schedulazione;
    \item \texttt{initial\_schedule}: eventuale risultato già calcolato da integrare;
    \item \texttt{is\_last\_schedule}: valore booleano che indica se l'elaborazione corrente è l'ultima;
    \item \texttt{future\_capacity\_by\_order}: dizionario opzionale con chiave l'identificativo dell'ordine e valore la capacità già riservata in pianificazioni future.
\end{itemize}
\subsection{Design pattern strutturali}
È stato usato il \textit{repository pattern}, tale approccio consiste nel creare delle classi (\textit{repository}) dotate dei metodi necessari per leggere o scrivere
il \textit{database}.
L'adozione di questo \textit{design pattern} porta a diversi vantaggi, tra cui:
\begin{itemize}
    \item Semplifica la logica di accesso ai dati, esponendo un'interfaccia consistente per la lettura e la scrittura;
    \item Migliora la testabilità del sistema, in quanto ogni \textit{repository} può essere sostituito facilmente da un \textit{mock};
    \item Migliora la pulizia e la leggibilità del codice;
    \item Permette di ridurre il tempo necessario ad un eventuale cambio di \textit{database}, in quanto necessiterebbe solo di una riscrittura delle classi \textit{repository}.
\end{itemize}
\newpage
\section{Struttura delle cartelle}
La struttura delle cartelle adottata per il progetto è la seguente:
\begin{itemize}
    \item \texttt{Mugalab-Automation}: cartella principale, contiene i file relativi alle \textit{variabili d'ambiente}, alla configurazione di Docker, il file \texttt{requirements.txt}, utilizzato per tenere traccia di tutte le dipendenze del sistema e il file \texttt{.gitignore} che riferisce al \textit{version control system} quali elementi ignorare;
    \begin{itemize}
        \item \texttt{app}: cartella contenente tutto il codice sorgente;
        \begin{itemize}
            \item \texttt{api}: cartella contenente i file che dichiarano le rotte \textit{API};
            \item \texttt{contexts}: cartella contenente i file che dichiarano gli oggetti utilizzati come contesto;
            \item \texttt{db}: cartella che contiene i file che dichiarano i dati per la connessione con il \textit{database};
            \item \texttt{dependencies}: cartella che contiene i file che dichiarano le classi e le funzioni utilizzate per effettuare \textit{dependency injection};
            \item \texttt{interfaces}: cartella che contiene i file che dichiarano le interfacce;
            \item \texttt{models}: cartella che contiene i file che dichiarano i \textit{modelli}, ovvero le classi che rappresentano le entità di dominio, validano i dati in ingresso e definiscono lo schema persistito nel database;
            \item \texttt{repositories}: cartella che contiene i file che dichiarano i \textit{repository} usati per leggere e/o scrivere dati nel \textit{database};
            \item \texttt{services}: cartella che contiene le classi che contengono tutta la \gls{businessLogicg} dell'applicazione;
            \item \texttt{tests}: cartella che contiene i \textit{test funzionali} prodotti.
        \end{itemize}
    \end{itemize}
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[alt={Struttura delle cartelle del progetto}, width=0.5\columnwidth]{img/struttura_cartelle.png}
	\caption{Struttura delle cartelle del progetto}
	\label{fig:folders-struct}
\end{figure}

\section{Lista dei modelli}
In questa sezione vengono descritti tutti i \textit{modelli}.
\subsection{Client}
\subsubsection{Scopo del modello}
Rappresenta un \textit{client} registrato e autorizzato ad utilizzare le rotte \textit{API} esposte dal sistema.
La struttura di questo \textit{modello} definisce la tabella \texttt{clients} (vedi sezione \ref{planner-database}).
\subsubsection{Definizione}
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/client.py}
\caption{Definizione del model Client}
\label{listing:model-client}
\end{listing}
\subsection{JWTConfig}
\subsubsection{Scopo del modello}
Questo \textit{modello} definisce ed espone la configurazione dei \textit{JSON Web Token}, in particolare definisce la chiave e l'algoritmo utilizzati per la firma e la scadenza in minuti.
\subsubsection{Definizione}
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/jwt_config.py}
\caption{Definizione del model JWTConfig}
\label{listing:model-jwt-config}
\end{listing}
\subsection{ScheduleRequest}
\subsubsection{Scopo del modello}
Questo \textit{modello} definisce e valida la struttura del corpo della richiesta da inviare per richiedere una pianificazione.
In particolare ogni oggetto di tipo \texttt{ScheduleRequest} deve contenere:
\begin{itemize}
    \item Un \textit{array} di \texttt{Order} (vedi \ref{model:order});
    \item Un \textit{array} di \texttt{Printer} (vedi \ref{model:printer});
    \item Un intero che specifica l'identificativo dell'utente che effettua la richiesta;
    \item Una stringa che specifica il \textit{token} da utilizzare per l'invio dei dati al gestionale.
\end{itemize}
\subsubsection{Definizione}
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/schedule_request.py}
\caption{Definizione del modello ScheduleRequest}
\label{listing:model-schedule-request}
\end{listing}
\subsection{ScheduleResponse}
\subsubsection{Scopo del modello}
Questo \textit{modello} definisce e valida la struttura del corpo della risposta, contenente la pianificazione, inviata al gestionale una volta terminato il calcolo dei risultati.
In particolare ogni oggetto di tipo \texttt{ScheduleResponse} deve contenere:
\begin{itemize}
    \item Un risultato di tipo \texttt{SchedulingResult} (vedi \ref{model:scheduling-result})
    \item Un \textit{array} di \texttt{Order} (vedi \ref{model:order});
    \item Un intero che specifica l'identificativo dell'utente che deve ricevere la pianificazione.
\end{itemize}
\subsubsection{Definizione}
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/schedule_response.py}
\caption{Definizione del modello ScheduleResponse}
\label{listing:model-schedule-response}
\end{listing}
\subsection{PrinterSchedule}
\label{model:printer-schedule}
\subsubsection{Scopo del modello}
Questo \textit{modello} definisce e valida la schedulazione proposta per una singola stampante.
In particolare ogni oggetto di tipo \texttt{PrinterSchedule} deve contenere:
\begin{itemize}
    \item Un \textit{array} di \texttt{ScheduledJob} (vedi \ref{model:scheduled-job});
    \item Un intero che indica i minuti di ritardo accumulati su quella specifica stampante;
    \item Un intero che specifica il conteggio dei lavori pianificati su quella stampante.
\end{itemize}
\subsubsection{Definizione}
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/printer_schedule.py}
\caption{Definizione del modello PrinterSchedule}
\label{listing:model-printer-schedule}
\end{listing}
\subsection{ScheduledJob}
\label{model:scheduled-job}
\subsubsection{Scopo del modello}
Questo \textit{modello} definisce e valida una singola istanza di un lavoro pianificato.
In particolare ogni oggetto di tipo \texttt{ScheduledJob} deve contenere:
\begin{itemize}
    \item Una stringa che indica il nome del lavoro;
    \item Una stringa che indica il materiale;
    \item Un oggetto di tipo \texttt{datetime} che indica data e ora di inizio del lavoro;
    \item Un oggetto di tipo \texttt{datetime} che indica data e ora di fine del lavoro;
    \item Un intero che indica la durata della stampa in minuti;
    \item Un intero che indica il ritardo nella esecuzione del lavoro in minuti;
    \item Un oggetto di tipo \texttt{Order} (vedi \ref{model:order});
    \item Un oggetto di tipo \texttt{datetime} che indica la scadenza del lavoro;
    \item Un oggetto di tipo \texttt{Plate} (vedi \ref{model:plate}).
\end{itemize}
\subsubsection{Definizione}
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/scheduled_job.py}
\caption{Definizione del modello ScheduledJob}
\label{listing:model-scheduled-job}
\end{listing}
\subsection{Summary}
\label{model:summary}
\subsubsection{Scopo del modello}
Questo \textit{modello} definisce e valida le statistiche finali della pianificazione richiesta.
In particolare ogni oggetto di tipo \texttt{Summary} deve contenere:
\begin{itemize}
    \item Un intero che indica il numero totale di minuti di ritardo;
    \item Un intero che indica il numero totale di lavori pianificati;
    \item Un intero che indica lo stato del solutore (in base al calcolo di una soluzione ottima, accettabile o non accettabile);
    \item Un intero che indica il numero totale di cambi di materiale;
    \item Un intero che indica il \gls{makespang} in minuti;
\end{itemize}
\subsubsection{Definizione}
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/summary.py}
\caption{Definizione del modello Summary}
\label{listing:model-summary}
\end{listing}
\subsection{Job}
\label{model:job}
\subsubsection{Scopo del modello}
Questo \textit{modello} definisce e valida una singola istanza di un lavoro da pianificare.
In particolare ogni oggetto di tipo \texttt{Job} deve contenere:
\begin{itemize}
    \item Una stringa che indica il nome del lavoro;
    \item Un oggetto di tipo \texttt{time} che indica durata della stampa;
    \item Un oggetto di tipo \texttt{Plate} (vedi \ref{model:plate});
    \item Un oggetto di tipo \texttt{datetime} che indica la scadenza del lavoro;
    \item Un oggetto di tipo \texttt{Order} (vedi \ref{model:order}).
\end{itemize}
\subsubsection{Definizione}
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/job.py}
\caption{Definizione del modello Job}
\label{listing:model-job}
\end{listing}
\subsection{Order}
\label{model:order}
\subsubsection{Scopo del modello}
Questo \texttt{modello} definisce e valida una singola istanza di un ordine di produzione.
In particolare ogni oggetto di tipo \texttt{Order} deve contenere:
\begin{itemize}
    \item Un intero che indica l'identificativo dell'ordine;
    \item Un oggetto di tipo \texttt{date} che indica la scadenza dell'ordine;
    \item Una stringa che indica il codice dell'ordine;
    \item Un intero che indica i pezzi ordinati;
    \item Un intero che indica i pezzi già stampati;
    \item Un oggetto di tipo \texttt{PrinterWork} (vedi \ref{model:printer-work}).
\end{itemize}
\subsubsection{Definizione}
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/order.py}
\caption{Definizione del modello Order}
\label{listing:model-order}
\end{listing}
\subsection{Plate}
\label{model:plate}
\subsubsection{Scopo del modello}
Questo \textit{modello} definisce e valida una singola istanza di un piatto di stampa.
In particolare ogni oggetto di tipo \texttt{Plate} deve contenere:
\begin{itemize}
    \item Un intero che indica l'identificativo del piatto;
    \item Un intero che indica il numero di pezzi presenti nel piatto;
    \item Un oggetto di tipo \texttt{time} che indica il tempo necessario per stampare un piatto.
\end{itemize}
\subsubsection{Definizione}
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/plate.py}
\caption{Definizione del modello Plate}
\label{listing:model-plate}
\end{listing}
\subsection{PrinterMaterial}
\label{model:printer-material}
\subsubsection{Scopo del modello}
Questo \textit{modello} valida e definisce una singola istanza di un materiale utilizzato per la stampa.
In particolare ogni oggetto di tipo \texttt{PrinterMaterial} deve contenere:
\begin{itemize}
    \item Un intero che indica l'identificativo del materiale;
    \item Una stringa che indica il nome del materiale.
\end{itemize}
\subsubsection{Definizione}
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/printer_material.py}
\caption{Definizione del modello PrinterMaterial}
\label{listing:model-printer-material}
\end{listing}
\subsection{PrinterWork}
\label{model:printer-work}
\subsubsection{Scopo del modello}
Questo \textit{modello} valida e definisce una singola istanza di un articolo da stampare.
In particolare ogni oggetto di tipo \texttt{PrinterWork} deve contenere:
\begin{itemize}
    \item Un intero che indica l'identificativo dell'articolo;
    \item Una stringa che indica il nome dell'articolo;
    \item Un oggetto di tipo \texttt{PrinterMaterial} (vedi \ref{model:printer-material});
    \item Un \textit{array} di oggetti di tipo \texttt{Plate} (vedi \ref{model:plate}) che indica i formati di piatti di stampa disponibili per l'articolo.
\end{itemize}
\subsubsection{Definizione}
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/printer_work.py}
\caption{Definizione del modello PrinterWork}
\label{listing:model-printer-work}
\end{listing}
\subsection{Printer}
\label{model:printer}
\subsubsection{Scopo del modello}
Questo \textit{modello} definisce e valida una singola istanza di una stampante.
In particolare ogni oggetto di tipo \texttt{Printer} deve contenere:
\begin{itemize}
    \item Un intero che indica l'identificativo della stampante;
    \item Una stringa che indica il nome della stampante.
\end{itemize}
\subsubsection{Definizione}
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/printer.py}
\caption{Definizione del modello Printer}
\label{listing:model-printer}
\end{listing}
\subsection{SchedulingResult}
\label{model:scheduling-result}
\subsubsection{Scopo del modello}
Questo \textit{modello} valida e definisce una risultato di schedulazione.
In particolare ogni oggetto di tipo \texttt{SchedulingResult} deve contenere:
\begin{itemize}
    \item Un oggetto di tipo \texttt{Summary} (vedi \ref{model:summary});
    \item Un dizionario che associa ad ogni stampante un oggetto di tipo \texttt{PrinterSchedule} (vedi \ref{model:printer-schedule})
\end{itemize}
\subsubsection{Definizione}
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/scheduling_result.py}
\caption{Definizione del modello SchedulingResult}
\label{listing:model-scheduling-result}
\end{listing}
\subsection{TaskVariable}
\subsubsection{Scopo del modello}
Questo \textit{modello} definisce una variabile utilizzata dalla libreria Google OR-Tools (vedi \ref{library:or-tools}) per identificare un lavoro da pianificare.
In particolare ogni oggetto di tipo \texttt{TaskVariable} deve contenere:
\begin{itemize}
    \item Un oggetto di tipo \texttt{IntVar} che rappresenta l'istante di inizio del lavoro espresso in minuti rispetto all'orario di inizio della schedulazione;
    \item Un oggetto di tipo \texttt{IntVar} che rappresenta l'istante di fine del lavoro espresso nello stesso riferimento temporale;
    \item Un oggetto di tipo \texttt{IntVar} che agisce come variabile booleana per indicare se il lavoro è stato assegnato a una stampante;
    \item Un oggetto di tipo \texttt{IntervalVar} che collega inizio, durata e fine della lavorazione e permette al solutore di imporre i vincoli di non sovrapposizione;
    \item Una stringa che indica il materiale richiesto dal lavoro;
    \item Un intero che indica la durata del lavoro in minuti;
    \item Un intero che rappresenta la deadline del lavoro in minuti rispetto all'orario di inizio della schedulazione;
    \item Un oggetto di tipo \texttt{Job} (vedi \ref{model:job}) che mantiene un riferimento al lavoro originale.
\end{itemize}
\subsubsection{Definizione}
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/task_variable.py}
\caption{Definizione del modello TaskVariable}
\label{listing:model-task-variable}
\end{listing}
\subsection{SchedulerConfig}
\subsubsection{Scopo del modello}
Questo \textit{modello} definisce la configurazione delle opzioni dello schedulatore.
In particolare ogni oggetto di tipo \texttt{SchedulerConfig} deve contenere:
\begin{itemize}
    \item Un intero che indica quanti minuti possiede una giornata;
    \item Un intero che indica dopo quanti minuti dall'inizio della giornata comincia il turno lavorativo;
    \item Un intero che indica dopo quanti minuti dall'inizio della giornata finisce il turno lavorativo;
    \item Un intero che indica la penalità per un cambio di materiale;
    \item Un intero che indica la penalità per ogni minuto di ritardo accumulato;
    \item Un intero che indica quanti minuti servono per un cambio piatto;
    \item Un numero a virgola mobile che indica quanti secondi può impiegare il solutore per la ricerca della soluzione ottima;
    \item Un valore booleano che indica se il solutore deve stampare a terminale il progresso della ricerca.
\end{itemize}
\subsubsection{Definizione}
\begin{listing}[H]
\inputminted[fontsize=\small, breaklines, bgcolor=mintedbackground, linenos=true]{python}{code/scheduler_config.py}
\caption{Definizione del modello TaskVariable}
\label{listing:model-scheduler-config}
\end{listing}
\section{Servizi}
In questa sezione vengono descritti i \textit{servizi} più rilevanti.
\subsection{OrderConversionService}
\subsubsection{Scopo}
Questo \textit{servizio} ha lo scopo di incapsulare la logica di conversione di un \textit{array} di oggetti di tipo \texttt{Order} ad un \textit{array} di oggetti di tipo \texttt{Job}, operazione necessaria 
per ottenere tutti i possibili lavori da pianificare nella coda di stampa.
Il metodo \texttt{convert\_orders\_to\_jobs} scansiona tutti gli ordini ricevuti come parametro, per ogni ordine controlla le tipologie di piatti stampabili per l'articolo richiesto
e calcola quanti piatti sono necessari per completare la richiesta per ogni variante di piatto.
Vengono poi costruiti gli oggetti di tipo \texttt{Job}, i quali potranno poi essere inseriti o meno nella coda di stampa in base alla richiesta.
\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/order_conversion_service.py}
\captionof{listing}{Implementazione del servizio OrderConversionService}
\subsection{SchedulingService}
\subsubsection{Scopo}
Questo \textit{servizio} ha lo scopo di orchestrare il processo di schedulazione.
Il metodo \texttt{schedule\_with\_batches} accetta come parametri un \textit{array} di \texttt{Job}, un \textit{array} di \texttt{Printer} e 
un oggetto di tipo \texttt{OrderingAlg} per la scelta dell'algoritmo da utilizzare (\textit{strategy pattern}).
I lavori da pianificare vengono divisi in insiemi (detti \textit{batch}) di dimensione fissa, questa scelta implementativa permette di ottenere una soluzione
qualitativamente inferiore a fronte di un forte incremento delle prestazioni, la dimensione dei batch rimane comunque configurabile attraverso la gestione delle \textit{variabili d'ambiente}.
Ogni \textit{batch} viene poi pianificato separatamente e unito agli altri.
Gli altri metodi presenti nella classe (qui omessi per semplicità) sono:
\begin{itemize}
    \item \texttt{\_\_get\_future\_capacity\_by\_order}: si occupa di calcolare la produzione possibile dei \textit{batch} futuri, per evitare sovra-produzione;
    \item \texttt{\_\_merge\_schedules}: si occupa di unire due schedulazioni appartenenti a \textit{batch} differenti;
    \item \texttt{\_\_get\_total\_material\_changes}: calcola il numero totale di cambi di materiale;
    \item \texttt{\_\_get\_total\_makespan}: calcola il \textit{makespan} totale;
    \item \texttt{\_\_split\_in\_batches}: divide l'\textit{array} di \texttt{Job} in \textit{batch};
    \item \texttt{\_\_set\_summary}: imposta l'oggetto \texttt{Summary} della soluzione, inserendo delle informazioni riassuntive sulla pianificazione.
\end{itemize}

\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/scheduling_service.py}
\captionof{listing}{Implementazione del servizio SchedulingService}
\newpage
\subsection{ORToolsPrintingScheduler}
\subsubsection{Scopo}
Questo \textit{servizio} ha lo scopo di utilizzare la libreria Google OR-Tools per istanziare le variabili necessarie per il modello CP-SAT, impostare i vincoli necessari,
definire la funzione obiettivo e chiamare il solutore.
Il servizio estende l'interfaccia \texttt{OrderingAlg}, pertanto definisce obbligatoriamente un metodo \texttt{schedule\_jobs} con i parametri descritti nella sezione \ref{listing:ordering-alg-py}.
Tale metodo si occupa di calcolare l'orizzonte temporale della soluzione (tramite il metodo \texttt{\_\_calculate\_horizon}) e di istanziare i servizi necessari (\texttt{VariableManager}, \texttt{ConstraintManager}, \texttt{SolutionFormatter} e 
\texttt{ObjectiveManager}) e orchestare le chiamate ai loro metodi pubblici.
\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/or_tools_printing_scheduler.py}
\captionof{listing}{Implementazione del servizio ORToolsPrintingScheduler}
\subsection{ConstraintManager}
\subsubsection{Scopo}
Questo \textit{servizio} ha lo scopo di dichiarare i vincoli della soluzione da trovare.
Il metodo \texttt{add\_initial\_state\_constraints} accetta come parametri un dizionario che associa la tupla nome lavoro-nome stampante al corrispondente oggetto di tipo
\texttt{TaskVariable}, un \textit{array} di \texttt{Printer} e un oggetto di tipo \texttt{SchedulingResult}.
Il suo scopo è quello di assicurarsi mediante la definizione degli appositi vincoli che ogni lavoro sia pianificato dopo il suo predecessore e che tra due lavori consecutivi 
passi il tempo necessario per il cambio piatto.
Il metodo \texttt{add\_basic\_constraints} accetta come parametri un dizionario che associa la tupla nome lavoro-nome stampante al corrispondente oggetto di tipo
\texttt{TaskVariable}, un \textit{array} di \texttt{Printer} e un \textit{array} di \texttt{Job}.
Il suo scopo è quello di orchestrare le chiamate ai metodi privati \texttt{\_\_add\_assignment\_constraints}, \texttt{\_\_add\_no\_overlap\_constraints}, \texttt{\_\_add\_start\_time\_constraints} e \texttt{\_\_create\_precedence\_constraints},
quest'ultimi si occupano, rispettivamente, di definire i vincoli che impongono che ogni lavoro sia pianificato su una sola stampante, non si sovrapponga con altri e che inizi durante la giornata lavorativa.

Il metodo \texttt{add\_production\_constraints} accetta come parametri un dizionario che associa la tupla nome lavoro-nome stampante al corrispondente oggetto di tipo
\texttt{TaskVariable}, un \textit{array} di \texttt{Printer}, un oggetto opzionale di tipo \texttt{SchedulingResult} e un dizionario che indica, per l'ordine specificato, quanti pezzi sono già previsti nei \textit{batch} successivi.
Il suo scopo è quello di assicurarsi, mediante la definizione dei vincoli necessari, che la produzione copra la richiesta anche in caso di divisione in \textit{batch}.

\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/constraint_manager.py}
\captionof{listing}{Implementazione del servizio ConstraintManager}
\subsection{VariableManager}
\subsubsection{Scopo}
Questo \textit{servizio} ha lo scopo di convertire gli oggetti di tipo \texttt{Job} a degli oggetti di tipo \texttt{TaskVariable}.
Il metodo \texttt{create\_variables} accetta come parametri un \textit{array} di \texttt{Job} e un \textit{array} di \texttt{Printer}.
Per ogni coppia \texttt{Job-Printer} viene chiamato il metodo \texttt{\_\_create\_task\_variables} il quale si occupa dell'effettiva creazione dell'oggetto di tipo \texttt{TaskVariable}.
\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/variable_manager.py}
\captionof{listing}{Implementazione del servizio VariableManager}
\subsection{ObjectiveManager}
\subsubsection{Scopo}
Questo \textit{servizio} si occupa di gestire la definizione della \gls{objectiveFunctiong}.
Il metodo \texttt{define\_objective} accetta come parametri un dizionario che associa la tupla nome lavoro-nome stampante al corrispondente oggetto di tipo
\texttt{TaskVariable}, un \textit{array} di \texttt{Printer}, un \textit{array} di \texttt{Job}, una variabile booleana che indica se il \textit{batch} esaminato è l'ultimo,
l'ultimo \textit{batch} pianificato, un dizionario che indica, per l'ordine specificato, quanti pezzi sono già previsti nei \textit{batch} successivi e l'ultimo \texttt{SchedulingResult} calcolato.
Tale metodo si occupa quindi di orchestrare le chiamate ai metodi privati \texttt{\_\_add\_timing\_penalties}, \texttt{\_\_add\_makespan\_objective} e \texttt{\_\_add\_production\_objective} i quali si occupano
rispettivamente di definire le penalità per i ritardi, aggiungere l'obiettivo di minimizzare il \textit{makespan} e minimizzare la sovraproduzione.
\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/objective_manager.py}
\captionof{listing}{Implementazione del servizio ObjectiveManager}
\subsection{SolutionFormatter}
\subsubsection{Scopo}
Questo \textit{servizio} si occupa di gestire la formattazione della soluzione e la creazione dell'oggetto \texttt{SchedulingResult}.
Il metodo \texttt{get\_solution\_dict} accetta come parametri l'istanza del solutore, un dizionario che associa la tupla nome lavoro-nome stampante al corrispondente oggetto di tipo
\texttt{TaskVariable}, un \textit{array} di \texttt{Printer} e una variabile \texttt{status} che indica lo stato del solutore.
Tale metodo si occupa quindi della costruzione della soluzione orchestrando le chiamate ai metodi \texttt{\_\_get\_status\_string}, \texttt{\_\_get\_printer\_schedule} e \texttt{\_\_update\_job\_start\_times} i quali si occupano,
rispettivamente, di convertire lo stato del solutore in una stringa, di costruire l'oggetto \texttt{PrinterSchedule} e aggiornare gli oggetti \texttt{Job} originali con gli orari di avvio calcolati.
\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/solution_formatter.py}
\captionof{listing}{Implementazione del servizio SolutionFormatter}
\section{Rotte API}
In questa sezione vengono descritte le rotte \textit{API} esposte dal sistema.
\subsection{\texttt{/schedule}}
\subsubsection{Scopo}
Questa rotta \textit{API} accetta come parametro un oggetto di tipo \texttt{ScheduleRequest}.
Se la validazione ha successo viene avviata una schedulazione.
\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/scheduling.py}
\captionof{listing}{Implementazione della rotta \texttt{/schedule}}
\subsection{\texttt{/token}}
\subsubsection{Scopo}
Questa rotta \textit{API} riceve come parametro le credenziali di un \textit{client} registrato e, se sono corrette, rilascia un nuovo \textit{JSON Web Token}.
\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/token.py}
\captionof{listing}{Implementazione della rotta \texttt{/token}}
\subsection{\texttt{/verifyToken}}
\subsubsection{Scopo}
Questa rotta \textit{API} riceve come parametro il \textit{JSON Web Token} inviato da un \textit{client} registrato e ne effettua la verifica.
\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/verify_token.py}
\captionof{listing}{Implementazione della rotta \texttt{/verifyToken}}
\section{Sicurezza del sistema}
In questa sezione vengono descritte tutte le scelte implementative riguardanti la sicurezza del sistema.
\subsection{Validazione delle richieste}
Il \textit{framework} FastAPI mette a disposizione una validazione automatica delle richieste inviate alle rotte \textit{API}, tale procedura
permette di scartare tutti gli input non conformi.
\subsection{JSON Web Token}
Per validare l'autore della richiesta è stata implementata una logica simile allo standard OAuth 2.0 Client Credentials Flow\footcite{site:oauth}.
Il funzionamento di tale logica è il seguente:
\begin{itemize}
    \item Il \textit{client} che deve utilizzare il sistema invia le sue credenziali al modulo di pianificazione inserendo nel corpo della richiesta i valori \texttt{client\_id} e \texttt{client\_secret};
    \item Il modulo di pianificazione valida le credenziali e risponde con un \textit{JSON Web Token} firmato con una chiave segreta tramite l'algoritmo \texttt{HS256};
    \item Il \textit{client} può inserire nell'intestazione della richiesta (detta anche \textit{header}) il \textit{JSON Web Token} ricevuto;
    \item Il modulo di pianificazione può validare il \textit{JSON Web Token} verificando la firma utilizzando la chiave segreta.
\end{itemize}
Le differenze rispetto allo standard sono le seguenti:
\begin{itemize}
    \item Non viene effettuata la rotazione delle chiavi;
    \item Il modulo di pianificazione svolge anche la funzione di \textit{authorization server};
\end{itemize}
È stato scelto assieme al tutor aziendale di non implementare lo standard nella sua totalità per riservare maggior tempo di sviluppo alle restanti funzionalità.
\label{section:system-security}

\section{Verifica e validazione}
L'ultimo periodo dello stage è stato dedicato alla fase di verifica e validazione di quanto prodotto.
Tale pratica consiste nella scrittura ed esecuzione di \textit{test di unità}, \textit{test funzionali} e \textit{test di integrazione} dedicati a verificare la copertura dei requisiti
e il funzionamento del sistema.
Il tempo a disposizione non è stato sufficiente alla scrittura di una suite completa di test, tuttavia sono stati scritti alcuni \textit{test funzionali} dedicati a verificare 
il funzionamento dello schedulatore e il rispetto dei principali vincoli.
\subsection{Test 1: ordine singolo}
\subsubsection{Scopo}
Questo test ha lo scopo di validare la capacità di pianificare un singolo ordine di produzione.
Il test si considera superato se il modulo pianifica correttamente l'ordine senza errori.
\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/test_single_order.py}
\captionof{listing}{Implementazione del test ordine singolo}
\subsection{Test 2: ordini con materiali diversi}
\subsubsection{Scopo}
Questo test ha lo scopo di validare la capacità di pianificare due ordini di produzione composti da prodotti stampati con due materiali differenti.
Il test si considera superato se il modulo pianifica correttamente l'ordine senza errori e minimizzando il numero di cambi di materiale.
\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/test_materials_optimization.py}
\captionof{listing}{Implementazione del test ordini con materiali diversi}
\subsection{Test 3: ordine urgente}
\subsubsection{Scopo}
Questo test ha lo scopo di validare la capacità di pianificare due ordini di produzione, di cui uno urgente.
Il test si considera superato se il modulo pianifica correttamente l'ordine senza errori e minimizzando i ritardi.
\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/test_urgent_order.py}
\captionof{listing}{Implementazione del test ordine urgente}
\subsection{Test 4: ordine parziale}
\subsubsection{Scopo}
Questo test ha lo scopo di validare la capacità di pianificare un ordine parziale.
Il test si considera superato se il modulo pianifica correttamente l'ordine senza errori e calcolando correttamente i pezzi da stampare.
\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/test_partial_order.py}
\captionof{listing}{Implementazione del test ordine parziale}
\subsection{Test 5: test vincoli di orario}
\subsubsection{Scopo}
Questo test ha lo scopo di validare la capacità di rispettare i vincoli di orario.
Il test si considera superato se il modulo pianifica correttamente l'ordine senza errori e rispettando i vincoli di orario.
\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/test_time_constraints.py}
\captionof{listing}{Implementazione del test vincoli di orario}
\subsection{Test 6: test scelta del piatto}
\subsubsection{Scopo}
Questo test ha lo scopo di validare la capacità di scegliere il piatto più adatto per minimizzare gli sprechi.
Il test si considera superato se il modulo pianifica correttamente l'ordine senza errori e minimizzando gli sprechi.
\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/test_plate_choice.py}
\captionof{listing}{Implementazione del test scelta del piatto}
\subsection{Test 7: test nessuna stampante disponibile}
\subsubsection{Scopo}
Questo test ha lo scopo di gestire il caso in cui non vi sia alcuna stampante disponibile.
Il test si considera superato se il modulo ritorna un errore.
\subsubsection{Implementazione}
\inputminted[fontsize=\small, breaklines, breakanywhere, bgcolor=mintedbackground, linenos=true]{python}{code/test_no_printer.py}
\captionof{listing}{Implementazione del test nessuna stampante disponibile}
\subsection{Esecuzione dei test}
Per eseguire i test è necessario aprire il terminale, navigare all'interno della cartella del progetto ed eseguire il comando \texttt{pytest}.
I risultati sono i seguenti:
\begin{table}[htbp]
    \centering
    \rowcolors{1}{}{tableGray}
    \begin{tabular}{|p{7cm}|p{2cm}|}
    \hline
    \multicolumn{1}{|c|}{\textbf{Test}} & \multicolumn{1}{c|}{\textbf{Esito}} \\
    \hline
    test\_materials\_optimization.py & Passato \\
    \hline
    test\_no\_printer.py & Passato \\
    \hline
    test\_partial\_order.py & Passato \\
    \hline
    test\_plate\_choice.py & Passato \\
    \hline
    test\_single\_order.py & Passato \\
    \hline
    test\_time\_constraints.py & Passato \\
    \hline
    test\_urgent\_order.py & Passato \\
    \hline
    \end{tabular}
    \caption{Tabella dei risultati dei test Pytest.}
    \label{tab:pytest-tests}
\end{table}
\newpage
